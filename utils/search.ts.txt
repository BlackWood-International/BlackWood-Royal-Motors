
/**
 * Calcule la distance de Levenshtein entre deux chaînes.
 * Indique le nombre minimum de modifications (ajout, suppression, substitution)
 * pour transformer a en b.
 */
function levenshtein(a: string, b: string): number {
  const an = a ? a.length : 0;
  const bn = b ? b.length : 0;
  if (an === 0) return bn;
  if (bn === 0) return an;

  const matrix = new Array(bn + 1);
  for (let i = 0; i <= bn; ++i) {
    let row = (matrix[i] = new Array(an + 1));
    row[0] = i;
  }
  const firstRow = matrix[0];
  for (let j = 1; j <= an; ++j) {
    firstRow[j] = j;
  }

  for (let i = 1; i <= bn; ++i) {
    for (let j = 1; j <= an; ++j) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1], // substitution
          matrix[i][j - 1],     // insertion
          matrix[i - 1][j]      // deletion
        ) + 1;
      }
    }
  }
  return matrix[bn][an];
}

/**
 * Recherche floue générique.
 * @param items Liste des objets à chercher
 * @param query Terme de recherche
 * @param keys Clés de l'objet sur lesquelles effectuer la recherche
 * @param threshold Seuil de tolérance (0.0 à 1.0, 1.0 = match parfait). Par défaut 0.4 (assez tolérant).
 */
export function fuzzySearch<T>(items: T[], query: string, keys: (keyof T)[], threshold: number = 0.4): T[] {
  if (!query || query.trim() === '') return items;
  
  const lowerQuery = query.toLowerCase().trim();

  // On map chaque item avec un score
  const results = items.map(item => {
    let bestScore = 0;

    for (const key of keys) {
      const value = String(item[key] || '').toLowerCase();
      
      // 1. Inclusion directe (Priorité maximale)
      if (value.includes(lowerQuery)) {
        // Score basé sur la longueur : plus le match est précis par rapport à la longueur totale, meilleur est le score.
        // ex: query="pan" dans "panto" (score haut) vs "pan" dans "panzerkampfwagen" (score plus bas)
        const score = 0.8 + (0.2 * (lowerQuery.length / value.length));
        if (score > bestScore) bestScore = score;
        continue;
      }

      // 2. Distance de Levenshtein (Tolérance aux fautes)
      const dist = levenshtein(value, lowerQuery);
      const maxLength = Math.max(value.length, lowerQuery.length);
      const similarity = 1 - (dist / maxLength); // 1 = identique, 0 = totalement différent

      if (similarity > bestScore) bestScore = similarity;
    }

    return { item, score: bestScore };
  });

  // Filtrage par seuil et tri par pertinence
  return results
    .filter(result => result.score >= threshold)
    .sort((a, b) => b.score - a.score)
    .map(result => result.item);
}
